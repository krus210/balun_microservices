// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"context"
	"github.com/sskorolev/balun_microservices/lib/app"
	"github.com/sskorolev/balun_microservices/lib/authmw"
	"github.com/sskorolev/balun_microservices/lib/config"
	"github.com/sskorolev/balun_microservices/lib/postgres"
	"users/internal/app/repository"
	"users/internal/app/usecase"
)

// Injectors from wire.go:

// InitializeApp - injector функция, которую сгенерирует Wire
// Возвращает AppContainer и cleanup функцию
func InitializeApp(ctx context.Context, cfg *config.StandardServiceConfig) (*AppContainer, func(), error) {
	app, err := provideApp(ctx, cfg)
	if err != nil {
		return nil, nil, err
	}
	transactionManagerAPI := provideTransactionManager(app)
	usersRepository := provideRepository(transactionManagerAPI)
	usecase := provideUsecase(usersRepository)
	authComponents, cleanup, err := provideAuthComponents(ctx, cfg)
	if err != nil {
		return nil, nil, err
	}
	validator := provideJWTValidator(authComponents)
	jwksProvider := provideJWKSCache(authComponents)
	appContainer := provideAppContainer(app, usecase, validator, jwksProvider)
	return appContainer, func() {
		cleanup()
	}, nil
}

// wire.go:

// AppContainer содержит App, Usecase и JWTValidator для передачи из Wire
type AppContainer struct {
	App          *app.App
	Usecase      usecase.Usecase
	JWTValidator *authmw.Validator
	JWKSCache    authmw.JWKSProvider
}

// provideApp создает App и инициализирует компоненты
func provideApp(ctx context.Context, cfg *config.StandardServiceConfig) (*app.App, error) {
	app2, err := app.NewApp(ctx, cfg)
	if err != nil {
		return nil, err
	}

	if err := app2.InitLogger(cfg.Logger, cfg.Service.Name, cfg.Service.Environment); err != nil {
		return nil, err
	}

	if err := app2.InitTracer(cfg.Tracer); err != nil {
		return nil, err
	}

	if err := app2.InitMetrics(cfg.Metrics, cfg.Service.Name); err != nil {
		return nil, err
	}

	if cfg.Server.Admin != nil {
		if err := app2.InitAdminServer(*cfg.Server.Admin); err != nil {
			return nil, err
		}
	}

	if err := app2.InitPostgres(ctx, cfg.Database); err != nil {
		return nil, err
	}

	return app2, nil
}

// provideTransactionManager получает transaction manager из App
func provideTransactionManager(app2 *app.App) postgres.TransactionManagerAPI {
	return app2.TransactionManager()
}

// provideRepository создает репозиторий и возвращает его как интерфейс
func provideRepository(tm postgres.TransactionManagerAPI) usecase.UsersRepository {
	return repository.NewRepository(tm)
}

// provideUsecase создает usecase и возвращает его как интерфейс
func provideUsecase(repo usecase.UsersRepository) usecase.Usecase {
	return usecase.NewUsecase(repo)
}

// provideAuthComponents создает и инициализирует auth компоненты
func provideAuthComponents(ctx context.Context, cfg *config.StandardServiceConfig) (*app.AuthComponents, func(), error) {
	return app.InitAuthComponents(ctx, cfg.AuthService, "users")
}

// provideJWKSCache извлекает JWKS кеш из auth компонентов
func provideJWKSCache(authComponents *app.AuthComponents) authmw.JWKSProvider {
	return authComponents.JWKSCache
}

// provideJWTValidator извлекает JWT validator из auth компонентов
func provideJWTValidator(authComponents *app.AuthComponents) *authmw.Validator {
	return authComponents.JWTValidator
}

// provideAppContainer создает контейнер с App, Usecase и JWT компонентами
func provideAppContainer(app2 *app.App, uc usecase.Usecase, validator *authmw.Validator, cache authmw.JWKSProvider) *AppContainer {
	return &AppContainer{
		App:          app2,
		Usecase:      uc,
		JWTValidator: validator,
		JWKSCache:    cache,
	}
}
