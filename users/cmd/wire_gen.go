// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"context"
	"github.com/sskorolev/balun_microservices/lib/app"
	"github.com/sskorolev/balun_microservices/lib/config"
	"github.com/sskorolev/balun_microservices/lib/postgres"
	"users/internal/app/repository"
	"users/internal/app/usecase"
)

// Injectors from wire.go:

// InitializeApp - injector функция, которую сгенерирует Wire
// Возвращает AppContainer и cleanup функцию
func InitializeApp(ctx context.Context, cfg *config.StandardServiceConfig) (*AppContainer, func(), error) {
	app, err := provideApp(ctx, cfg)
	if err != nil {
		return nil, nil, err
	}
	transactionManagerAPI := provideTransactionManager(app)
	usersRepository := provideRepository(transactionManagerAPI)
	usecase := provideUsecase(usersRepository)
	appContainer := provideAppContainer(app, usecase)
	return appContainer, func() {
	}, nil
}

// wire.go:

// AppContainer содержит App и Usecase для передачи из Wire
type AppContainer struct {
	App     *app.App
	Usecase usecase.Usecase
}

// provideApp создает App и инициализирует компоненты
func provideApp(ctx context.Context, cfg *config.StandardServiceConfig) (*app.App, error) {
	app2, err := app.NewApp(ctx, cfg)
	if err != nil {
		return nil, err
	}

	if err := app2.InitLogger(cfg.Logger, cfg.Service.Name, cfg.Service.Environment); err != nil {
		return nil, err
	}

	if err := app2.InitTracer(cfg.Tracer); err != nil {
		return nil, err
	}

	if err := app2.InitMetrics(cfg.Metrics, cfg.Service.Name); err != nil {
		return nil, err
	}

	if cfg.Server.Admin != nil {
		if err := app2.InitAdminServer(*cfg.Server.Admin); err != nil {
			return nil, err
		}
	}

	if err := app2.InitPostgres(ctx, cfg.Database); err != nil {
		return nil, err
	}

	return app2, nil
}

// provideTransactionManager получает transaction manager из App
func provideTransactionManager(app2 *app.App) postgres.TransactionManagerAPI {
	return app2.TransactionManager()
}

// provideRepository создает репозиторий и возвращает его как интерфейс
func provideRepository(tm postgres.TransactionManagerAPI) usecase.UsersRepository {
	return repository.NewRepository(tm)
}

// provideUsecase создает usecase и возвращает его как интерфейс
func provideUsecase(repo usecase.UsersRepository) usecase.Usecase {
	return usecase.NewUsecase(repo)
}

// provideAppContainer создает контейнер с App и Usecase
func provideAppContainer(app2 *app.App, uc usecase.Usecase) *AppContainer {
	return &AppContainer{
		App:     app2,
		Usecase: uc,
	}
}
