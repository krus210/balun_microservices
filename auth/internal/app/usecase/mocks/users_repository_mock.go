// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

import (
	"auth/internal/app/models"
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// UsersRepositoryMock implements mm_usecase.UsersRepository
type UsersRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetUserByEmail          func(ctx context.Context, email string) (up1 *models.User, err error)
	funcGetUserByEmailOrigin    string
	inspectFuncGetUserByEmail   func(ctx context.Context, email string)
	afterGetUserByEmailCounter  uint64
	beforeGetUserByEmailCounter uint64
	GetUserByEmailMock          mUsersRepositoryMockGetUserByEmail

	funcGetUserByID          func(ctx context.Context, userID int64) (up1 *models.User, err error)
	funcGetUserByIDOrigin    string
	inspectFuncGetUserByID   func(ctx context.Context, userID int64)
	afterGetUserByIDCounter  uint64
	beforeGetUserByIDCounter uint64
	GetUserByIDMock          mUsersRepositoryMockGetUserByID

	funcSaveUser          func(ctx context.Context, email string, password string) (up1 *models.User, err error)
	funcSaveUserOrigin    string
	inspectFuncSaveUser   func(ctx context.Context, email string, password string)
	afterSaveUserCounter  uint64
	beforeSaveUserCounter uint64
	SaveUserMock          mUsersRepositoryMockSaveUser

	funcUpdateUser          func(ctx context.Context, user *models.User) (err error)
	funcUpdateUserOrigin    string
	inspectFuncUpdateUser   func(ctx context.Context, user *models.User)
	afterUpdateUserCounter  uint64
	beforeUpdateUserCounter uint64
	UpdateUserMock          mUsersRepositoryMockUpdateUser
}

// NewUsersRepositoryMock returns a mock for mm_usecase.UsersRepository
func NewUsersRepositoryMock(t minimock.Tester) *UsersRepositoryMock {
	m := &UsersRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetUserByEmailMock = mUsersRepositoryMockGetUserByEmail{mock: m}
	m.GetUserByEmailMock.callArgs = []*UsersRepositoryMockGetUserByEmailParams{}

	m.GetUserByIDMock = mUsersRepositoryMockGetUserByID{mock: m}
	m.GetUserByIDMock.callArgs = []*UsersRepositoryMockGetUserByIDParams{}

	m.SaveUserMock = mUsersRepositoryMockSaveUser{mock: m}
	m.SaveUserMock.callArgs = []*UsersRepositoryMockSaveUserParams{}

	m.UpdateUserMock = mUsersRepositoryMockUpdateUser{mock: m}
	m.UpdateUserMock.callArgs = []*UsersRepositoryMockUpdateUserParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUsersRepositoryMockGetUserByEmail struct {
	optional           bool
	mock               *UsersRepositoryMock
	defaultExpectation *UsersRepositoryMockGetUserByEmailExpectation
	expectations       []*UsersRepositoryMockGetUserByEmailExpectation

	callArgs []*UsersRepositoryMockGetUserByEmailParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UsersRepositoryMockGetUserByEmailExpectation specifies expectation struct of the UsersRepository.GetUserByEmail
type UsersRepositoryMockGetUserByEmailExpectation struct {
	mock               *UsersRepositoryMock
	params             *UsersRepositoryMockGetUserByEmailParams
	paramPtrs          *UsersRepositoryMockGetUserByEmailParamPtrs
	expectationOrigins UsersRepositoryMockGetUserByEmailExpectationOrigins
	results            *UsersRepositoryMockGetUserByEmailResults
	returnOrigin       string
	Counter            uint64
}

// UsersRepositoryMockGetUserByEmailParams contains parameters of the UsersRepository.GetUserByEmail
type UsersRepositoryMockGetUserByEmailParams struct {
	ctx   context.Context
	email string
}

// UsersRepositoryMockGetUserByEmailParamPtrs contains pointers to parameters of the UsersRepository.GetUserByEmail
type UsersRepositoryMockGetUserByEmailParamPtrs struct {
	ctx   *context.Context
	email *string
}

// UsersRepositoryMockGetUserByEmailResults contains results of the UsersRepository.GetUserByEmail
type UsersRepositoryMockGetUserByEmailResults struct {
	up1 *models.User
	err error
}

// UsersRepositoryMockGetUserByEmailOrigins contains origins of expectations of the UsersRepository.GetUserByEmail
type UsersRepositoryMockGetUserByEmailExpectationOrigins struct {
	origin      string
	originCtx   string
	originEmail string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserByEmail *mUsersRepositoryMockGetUserByEmail) Optional() *mUsersRepositoryMockGetUserByEmail {
	mmGetUserByEmail.optional = true
	return mmGetUserByEmail
}

// Expect sets up expected params for UsersRepository.GetUserByEmail
func (mmGetUserByEmail *mUsersRepositoryMockGetUserByEmail) Expect(ctx context.Context, email string) *mUsersRepositoryMockGetUserByEmail {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("UsersRepositoryMock.GetUserByEmail mock is already set by Set")
	}

	if mmGetUserByEmail.defaultExpectation == nil {
		mmGetUserByEmail.defaultExpectation = &UsersRepositoryMockGetUserByEmailExpectation{}
	}

	if mmGetUserByEmail.defaultExpectation.paramPtrs != nil {
		mmGetUserByEmail.mock.t.Fatalf("UsersRepositoryMock.GetUserByEmail mock is already set by ExpectParams functions")
	}

	mmGetUserByEmail.defaultExpectation.params = &UsersRepositoryMockGetUserByEmailParams{ctx, email}
	mmGetUserByEmail.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserByEmail.expectations {
		if minimock.Equal(e.params, mmGetUserByEmail.defaultExpectation.params) {
			mmGetUserByEmail.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserByEmail.defaultExpectation.params)
		}
	}

	return mmGetUserByEmail
}

// ExpectCtxParam1 sets up expected param ctx for UsersRepository.GetUserByEmail
func (mmGetUserByEmail *mUsersRepositoryMockGetUserByEmail) ExpectCtxParam1(ctx context.Context) *mUsersRepositoryMockGetUserByEmail {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("UsersRepositoryMock.GetUserByEmail mock is already set by Set")
	}

	if mmGetUserByEmail.defaultExpectation == nil {
		mmGetUserByEmail.defaultExpectation = &UsersRepositoryMockGetUserByEmailExpectation{}
	}

	if mmGetUserByEmail.defaultExpectation.params != nil {
		mmGetUserByEmail.mock.t.Fatalf("UsersRepositoryMock.GetUserByEmail mock is already set by Expect")
	}

	if mmGetUserByEmail.defaultExpectation.paramPtrs == nil {
		mmGetUserByEmail.defaultExpectation.paramPtrs = &UsersRepositoryMockGetUserByEmailParamPtrs{}
	}
	mmGetUserByEmail.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserByEmail.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserByEmail
}

// ExpectEmailParam2 sets up expected param email for UsersRepository.GetUserByEmail
func (mmGetUserByEmail *mUsersRepositoryMockGetUserByEmail) ExpectEmailParam2(email string) *mUsersRepositoryMockGetUserByEmail {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("UsersRepositoryMock.GetUserByEmail mock is already set by Set")
	}

	if mmGetUserByEmail.defaultExpectation == nil {
		mmGetUserByEmail.defaultExpectation = &UsersRepositoryMockGetUserByEmailExpectation{}
	}

	if mmGetUserByEmail.defaultExpectation.params != nil {
		mmGetUserByEmail.mock.t.Fatalf("UsersRepositoryMock.GetUserByEmail mock is already set by Expect")
	}

	if mmGetUserByEmail.defaultExpectation.paramPtrs == nil {
		mmGetUserByEmail.defaultExpectation.paramPtrs = &UsersRepositoryMockGetUserByEmailParamPtrs{}
	}
	mmGetUserByEmail.defaultExpectation.paramPtrs.email = &email
	mmGetUserByEmail.defaultExpectation.expectationOrigins.originEmail = minimock.CallerInfo(1)

	return mmGetUserByEmail
}

// Inspect accepts an inspector function that has same arguments as the UsersRepository.GetUserByEmail
func (mmGetUserByEmail *mUsersRepositoryMockGetUserByEmail) Inspect(f func(ctx context.Context, email string)) *mUsersRepositoryMockGetUserByEmail {
	if mmGetUserByEmail.mock.inspectFuncGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("Inspect function is already set for UsersRepositoryMock.GetUserByEmail")
	}

	mmGetUserByEmail.mock.inspectFuncGetUserByEmail = f

	return mmGetUserByEmail
}

// Return sets up results that will be returned by UsersRepository.GetUserByEmail
func (mmGetUserByEmail *mUsersRepositoryMockGetUserByEmail) Return(up1 *models.User, err error) *UsersRepositoryMock {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("UsersRepositoryMock.GetUserByEmail mock is already set by Set")
	}

	if mmGetUserByEmail.defaultExpectation == nil {
		mmGetUserByEmail.defaultExpectation = &UsersRepositoryMockGetUserByEmailExpectation{mock: mmGetUserByEmail.mock}
	}
	mmGetUserByEmail.defaultExpectation.results = &UsersRepositoryMockGetUserByEmailResults{up1, err}
	mmGetUserByEmail.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserByEmail.mock
}

// Set uses given function f to mock the UsersRepository.GetUserByEmail method
func (mmGetUserByEmail *mUsersRepositoryMockGetUserByEmail) Set(f func(ctx context.Context, email string) (up1 *models.User, err error)) *UsersRepositoryMock {
	if mmGetUserByEmail.defaultExpectation != nil {
		mmGetUserByEmail.mock.t.Fatalf("Default expectation is already set for the UsersRepository.GetUserByEmail method")
	}

	if len(mmGetUserByEmail.expectations) > 0 {
		mmGetUserByEmail.mock.t.Fatalf("Some expectations are already set for the UsersRepository.GetUserByEmail method")
	}

	mmGetUserByEmail.mock.funcGetUserByEmail = f
	mmGetUserByEmail.mock.funcGetUserByEmailOrigin = minimock.CallerInfo(1)
	return mmGetUserByEmail.mock
}

// When sets expectation for the UsersRepository.GetUserByEmail which will trigger the result defined by the following
// Then helper
func (mmGetUserByEmail *mUsersRepositoryMockGetUserByEmail) When(ctx context.Context, email string) *UsersRepositoryMockGetUserByEmailExpectation {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("UsersRepositoryMock.GetUserByEmail mock is already set by Set")
	}

	expectation := &UsersRepositoryMockGetUserByEmailExpectation{
		mock:               mmGetUserByEmail.mock,
		params:             &UsersRepositoryMockGetUserByEmailParams{ctx, email},
		expectationOrigins: UsersRepositoryMockGetUserByEmailExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserByEmail.expectations = append(mmGetUserByEmail.expectations, expectation)
	return expectation
}

// Then sets up UsersRepository.GetUserByEmail return parameters for the expectation previously defined by the When method
func (e *UsersRepositoryMockGetUserByEmailExpectation) Then(up1 *models.User, err error) *UsersRepositoryMock {
	e.results = &UsersRepositoryMockGetUserByEmailResults{up1, err}
	return e.mock
}

// Times sets number of times UsersRepository.GetUserByEmail should be invoked
func (mmGetUserByEmail *mUsersRepositoryMockGetUserByEmail) Times(n uint64) *mUsersRepositoryMockGetUserByEmail {
	if n == 0 {
		mmGetUserByEmail.mock.t.Fatalf("Times of UsersRepositoryMock.GetUserByEmail mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserByEmail.expectedInvocations, n)
	mmGetUserByEmail.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserByEmail
}

func (mmGetUserByEmail *mUsersRepositoryMockGetUserByEmail) invocationsDone() bool {
	if len(mmGetUserByEmail.expectations) == 0 && mmGetUserByEmail.defaultExpectation == nil && mmGetUserByEmail.mock.funcGetUserByEmail == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserByEmail.mock.afterGetUserByEmailCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserByEmail.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserByEmail implements mm_usecase.UsersRepository
func (mmGetUserByEmail *UsersRepositoryMock) GetUserByEmail(ctx context.Context, email string) (up1 *models.User, err error) {
	mm_atomic.AddUint64(&mmGetUserByEmail.beforeGetUserByEmailCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserByEmail.afterGetUserByEmailCounter, 1)

	mmGetUserByEmail.t.Helper()

	if mmGetUserByEmail.inspectFuncGetUserByEmail != nil {
		mmGetUserByEmail.inspectFuncGetUserByEmail(ctx, email)
	}

	mm_params := UsersRepositoryMockGetUserByEmailParams{ctx, email}

	// Record call args
	mmGetUserByEmail.GetUserByEmailMock.mutex.Lock()
	mmGetUserByEmail.GetUserByEmailMock.callArgs = append(mmGetUserByEmail.GetUserByEmailMock.callArgs, &mm_params)
	mmGetUserByEmail.GetUserByEmailMock.mutex.Unlock()

	for _, e := range mmGetUserByEmail.GetUserByEmailMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUserByEmail.GetUserByEmailMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.paramPtrs

		mm_got := UsersRepositoryMockGetUserByEmailParams{ctx, email}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserByEmail.t.Errorf("UsersRepositoryMock.GetUserByEmail got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.email != nil && !minimock.Equal(*mm_want_ptrs.email, mm_got.email) {
				mmGetUserByEmail.t.Errorf("UsersRepositoryMock.GetUserByEmail got unexpected parameter email, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.expectationOrigins.originEmail, *mm_want_ptrs.email, mm_got.email, minimock.Diff(*mm_want_ptrs.email, mm_got.email))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserByEmail.t.Errorf("UsersRepositoryMock.GetUserByEmail got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserByEmail.t.Fatal("No results are set for the UsersRepositoryMock.GetUserByEmail")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUserByEmail.funcGetUserByEmail != nil {
		return mmGetUserByEmail.funcGetUserByEmail(ctx, email)
	}
	mmGetUserByEmail.t.Fatalf("Unexpected call to UsersRepositoryMock.GetUserByEmail. %v %v", ctx, email)
	return
}

// GetUserByEmailAfterCounter returns a count of finished UsersRepositoryMock.GetUserByEmail invocations
func (mmGetUserByEmail *UsersRepositoryMock) GetUserByEmailAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByEmail.afterGetUserByEmailCounter)
}

// GetUserByEmailBeforeCounter returns a count of UsersRepositoryMock.GetUserByEmail invocations
func (mmGetUserByEmail *UsersRepositoryMock) GetUserByEmailBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByEmail.beforeGetUserByEmailCounter)
}

// Calls returns a list of arguments used in each call to UsersRepositoryMock.GetUserByEmail.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserByEmail *mUsersRepositoryMockGetUserByEmail) Calls() []*UsersRepositoryMockGetUserByEmailParams {
	mmGetUserByEmail.mutex.RLock()

	argCopy := make([]*UsersRepositoryMockGetUserByEmailParams, len(mmGetUserByEmail.callArgs))
	copy(argCopy, mmGetUserByEmail.callArgs)

	mmGetUserByEmail.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserByEmailDone returns true if the count of the GetUserByEmail invocations corresponds
// the number of defined expectations
func (m *UsersRepositoryMock) MinimockGetUserByEmailDone() bool {
	if m.GetUserByEmailMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserByEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserByEmailMock.invocationsDone()
}

// MinimockGetUserByEmailInspect logs each unmet expectation
func (m *UsersRepositoryMock) MinimockGetUserByEmailInspect() {
	for _, e := range m.GetUserByEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersRepositoryMock.GetUserByEmail at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserByEmailCounter := mm_atomic.LoadUint64(&m.afterGetUserByEmailCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByEmailMock.defaultExpectation != nil && afterGetUserByEmailCounter < 1 {
		if m.GetUserByEmailMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UsersRepositoryMock.GetUserByEmail at\n%s", m.GetUserByEmailMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UsersRepositoryMock.GetUserByEmail at\n%s with params: %#v", m.GetUserByEmailMock.defaultExpectation.expectationOrigins.origin, *m.GetUserByEmailMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByEmail != nil && afterGetUserByEmailCounter < 1 {
		m.t.Errorf("Expected call to UsersRepositoryMock.GetUserByEmail at\n%s", m.funcGetUserByEmailOrigin)
	}

	if !m.GetUserByEmailMock.invocationsDone() && afterGetUserByEmailCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersRepositoryMock.GetUserByEmail at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserByEmailMock.expectedInvocations), m.GetUserByEmailMock.expectedInvocationsOrigin, afterGetUserByEmailCounter)
	}
}

type mUsersRepositoryMockGetUserByID struct {
	optional           bool
	mock               *UsersRepositoryMock
	defaultExpectation *UsersRepositoryMockGetUserByIDExpectation
	expectations       []*UsersRepositoryMockGetUserByIDExpectation

	callArgs []*UsersRepositoryMockGetUserByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UsersRepositoryMockGetUserByIDExpectation specifies expectation struct of the UsersRepository.GetUserByID
type UsersRepositoryMockGetUserByIDExpectation struct {
	mock               *UsersRepositoryMock
	params             *UsersRepositoryMockGetUserByIDParams
	paramPtrs          *UsersRepositoryMockGetUserByIDParamPtrs
	expectationOrigins UsersRepositoryMockGetUserByIDExpectationOrigins
	results            *UsersRepositoryMockGetUserByIDResults
	returnOrigin       string
	Counter            uint64
}

// UsersRepositoryMockGetUserByIDParams contains parameters of the UsersRepository.GetUserByID
type UsersRepositoryMockGetUserByIDParams struct {
	ctx    context.Context
	userID int64
}

// UsersRepositoryMockGetUserByIDParamPtrs contains pointers to parameters of the UsersRepository.GetUserByID
type UsersRepositoryMockGetUserByIDParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// UsersRepositoryMockGetUserByIDResults contains results of the UsersRepository.GetUserByID
type UsersRepositoryMockGetUserByIDResults struct {
	up1 *models.User
	err error
}

// UsersRepositoryMockGetUserByIDOrigins contains origins of expectations of the UsersRepository.GetUserByID
type UsersRepositoryMockGetUserByIDExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserByID *mUsersRepositoryMockGetUserByID) Optional() *mUsersRepositoryMockGetUserByID {
	mmGetUserByID.optional = true
	return mmGetUserByID
}

// Expect sets up expected params for UsersRepository.GetUserByID
func (mmGetUserByID *mUsersRepositoryMockGetUserByID) Expect(ctx context.Context, userID int64) *mUsersRepositoryMockGetUserByID {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("UsersRepositoryMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &UsersRepositoryMockGetUserByIDExpectation{}
	}

	if mmGetUserByID.defaultExpectation.paramPtrs != nil {
		mmGetUserByID.mock.t.Fatalf("UsersRepositoryMock.GetUserByID mock is already set by ExpectParams functions")
	}

	mmGetUserByID.defaultExpectation.params = &UsersRepositoryMockGetUserByIDParams{ctx, userID}
	mmGetUserByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserByID.expectations {
		if minimock.Equal(e.params, mmGetUserByID.defaultExpectation.params) {
			mmGetUserByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserByID.defaultExpectation.params)
		}
	}

	return mmGetUserByID
}

// ExpectCtxParam1 sets up expected param ctx for UsersRepository.GetUserByID
func (mmGetUserByID *mUsersRepositoryMockGetUserByID) ExpectCtxParam1(ctx context.Context) *mUsersRepositoryMockGetUserByID {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("UsersRepositoryMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &UsersRepositoryMockGetUserByIDExpectation{}
	}

	if mmGetUserByID.defaultExpectation.params != nil {
		mmGetUserByID.mock.t.Fatalf("UsersRepositoryMock.GetUserByID mock is already set by Expect")
	}

	if mmGetUserByID.defaultExpectation.paramPtrs == nil {
		mmGetUserByID.defaultExpectation.paramPtrs = &UsersRepositoryMockGetUserByIDParamPtrs{}
	}
	mmGetUserByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserByID
}

// ExpectUserIDParam2 sets up expected param userID for UsersRepository.GetUserByID
func (mmGetUserByID *mUsersRepositoryMockGetUserByID) ExpectUserIDParam2(userID int64) *mUsersRepositoryMockGetUserByID {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("UsersRepositoryMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &UsersRepositoryMockGetUserByIDExpectation{}
	}

	if mmGetUserByID.defaultExpectation.params != nil {
		mmGetUserByID.mock.t.Fatalf("UsersRepositoryMock.GetUserByID mock is already set by Expect")
	}

	if mmGetUserByID.defaultExpectation.paramPtrs == nil {
		mmGetUserByID.defaultExpectation.paramPtrs = &UsersRepositoryMockGetUserByIDParamPtrs{}
	}
	mmGetUserByID.defaultExpectation.paramPtrs.userID = &userID
	mmGetUserByID.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetUserByID
}

// Inspect accepts an inspector function that has same arguments as the UsersRepository.GetUserByID
func (mmGetUserByID *mUsersRepositoryMockGetUserByID) Inspect(f func(ctx context.Context, userID int64)) *mUsersRepositoryMockGetUserByID {
	if mmGetUserByID.mock.inspectFuncGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("Inspect function is already set for UsersRepositoryMock.GetUserByID")
	}

	mmGetUserByID.mock.inspectFuncGetUserByID = f

	return mmGetUserByID
}

// Return sets up results that will be returned by UsersRepository.GetUserByID
func (mmGetUserByID *mUsersRepositoryMockGetUserByID) Return(up1 *models.User, err error) *UsersRepositoryMock {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("UsersRepositoryMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &UsersRepositoryMockGetUserByIDExpectation{mock: mmGetUserByID.mock}
	}
	mmGetUserByID.defaultExpectation.results = &UsersRepositoryMockGetUserByIDResults{up1, err}
	mmGetUserByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserByID.mock
}

// Set uses given function f to mock the UsersRepository.GetUserByID method
func (mmGetUserByID *mUsersRepositoryMockGetUserByID) Set(f func(ctx context.Context, userID int64) (up1 *models.User, err error)) *UsersRepositoryMock {
	if mmGetUserByID.defaultExpectation != nil {
		mmGetUserByID.mock.t.Fatalf("Default expectation is already set for the UsersRepository.GetUserByID method")
	}

	if len(mmGetUserByID.expectations) > 0 {
		mmGetUserByID.mock.t.Fatalf("Some expectations are already set for the UsersRepository.GetUserByID method")
	}

	mmGetUserByID.mock.funcGetUserByID = f
	mmGetUserByID.mock.funcGetUserByIDOrigin = minimock.CallerInfo(1)
	return mmGetUserByID.mock
}

// When sets expectation for the UsersRepository.GetUserByID which will trigger the result defined by the following
// Then helper
func (mmGetUserByID *mUsersRepositoryMockGetUserByID) When(ctx context.Context, userID int64) *UsersRepositoryMockGetUserByIDExpectation {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("UsersRepositoryMock.GetUserByID mock is already set by Set")
	}

	expectation := &UsersRepositoryMockGetUserByIDExpectation{
		mock:               mmGetUserByID.mock,
		params:             &UsersRepositoryMockGetUserByIDParams{ctx, userID},
		expectationOrigins: UsersRepositoryMockGetUserByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserByID.expectations = append(mmGetUserByID.expectations, expectation)
	return expectation
}

// Then sets up UsersRepository.GetUserByID return parameters for the expectation previously defined by the When method
func (e *UsersRepositoryMockGetUserByIDExpectation) Then(up1 *models.User, err error) *UsersRepositoryMock {
	e.results = &UsersRepositoryMockGetUserByIDResults{up1, err}
	return e.mock
}

// Times sets number of times UsersRepository.GetUserByID should be invoked
func (mmGetUserByID *mUsersRepositoryMockGetUserByID) Times(n uint64) *mUsersRepositoryMockGetUserByID {
	if n == 0 {
		mmGetUserByID.mock.t.Fatalf("Times of UsersRepositoryMock.GetUserByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserByID.expectedInvocations, n)
	mmGetUserByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserByID
}

func (mmGetUserByID *mUsersRepositoryMockGetUserByID) invocationsDone() bool {
	if len(mmGetUserByID.expectations) == 0 && mmGetUserByID.defaultExpectation == nil && mmGetUserByID.mock.funcGetUserByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserByID.mock.afterGetUserByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserByID implements mm_usecase.UsersRepository
func (mmGetUserByID *UsersRepositoryMock) GetUserByID(ctx context.Context, userID int64) (up1 *models.User, err error) {
	mm_atomic.AddUint64(&mmGetUserByID.beforeGetUserByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserByID.afterGetUserByIDCounter, 1)

	mmGetUserByID.t.Helper()

	if mmGetUserByID.inspectFuncGetUserByID != nil {
		mmGetUserByID.inspectFuncGetUserByID(ctx, userID)
	}

	mm_params := UsersRepositoryMockGetUserByIDParams{ctx, userID}

	// Record call args
	mmGetUserByID.GetUserByIDMock.mutex.Lock()
	mmGetUserByID.GetUserByIDMock.callArgs = append(mmGetUserByID.GetUserByIDMock.callArgs, &mm_params)
	mmGetUserByID.GetUserByIDMock.mutex.Unlock()

	for _, e := range mmGetUserByID.GetUserByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUserByID.GetUserByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserByID.GetUserByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserByID.GetUserByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserByID.GetUserByIDMock.defaultExpectation.paramPtrs

		mm_got := UsersRepositoryMockGetUserByIDParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserByID.t.Errorf("UsersRepositoryMock.GetUserByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByID.GetUserByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetUserByID.t.Errorf("UsersRepositoryMock.GetUserByID got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByID.GetUserByIDMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserByID.t.Errorf("UsersRepositoryMock.GetUserByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserByID.GetUserByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserByID.GetUserByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserByID.t.Fatal("No results are set for the UsersRepositoryMock.GetUserByID")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUserByID.funcGetUserByID != nil {
		return mmGetUserByID.funcGetUserByID(ctx, userID)
	}
	mmGetUserByID.t.Fatalf("Unexpected call to UsersRepositoryMock.GetUserByID. %v %v", ctx, userID)
	return
}

// GetUserByIDAfterCounter returns a count of finished UsersRepositoryMock.GetUserByID invocations
func (mmGetUserByID *UsersRepositoryMock) GetUserByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByID.afterGetUserByIDCounter)
}

// GetUserByIDBeforeCounter returns a count of UsersRepositoryMock.GetUserByID invocations
func (mmGetUserByID *UsersRepositoryMock) GetUserByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByID.beforeGetUserByIDCounter)
}

// Calls returns a list of arguments used in each call to UsersRepositoryMock.GetUserByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserByID *mUsersRepositoryMockGetUserByID) Calls() []*UsersRepositoryMockGetUserByIDParams {
	mmGetUserByID.mutex.RLock()

	argCopy := make([]*UsersRepositoryMockGetUserByIDParams, len(mmGetUserByID.callArgs))
	copy(argCopy, mmGetUserByID.callArgs)

	mmGetUserByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserByIDDone returns true if the count of the GetUserByID invocations corresponds
// the number of defined expectations
func (m *UsersRepositoryMock) MinimockGetUserByIDDone() bool {
	if m.GetUserByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserByIDMock.invocationsDone()
}

// MinimockGetUserByIDInspect logs each unmet expectation
func (m *UsersRepositoryMock) MinimockGetUserByIDInspect() {
	for _, e := range m.GetUserByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersRepositoryMock.GetUserByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserByIDCounter := mm_atomic.LoadUint64(&m.afterGetUserByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByIDMock.defaultExpectation != nil && afterGetUserByIDCounter < 1 {
		if m.GetUserByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UsersRepositoryMock.GetUserByID at\n%s", m.GetUserByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UsersRepositoryMock.GetUserByID at\n%s with params: %#v", m.GetUserByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetUserByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByID != nil && afterGetUserByIDCounter < 1 {
		m.t.Errorf("Expected call to UsersRepositoryMock.GetUserByID at\n%s", m.funcGetUserByIDOrigin)
	}

	if !m.GetUserByIDMock.invocationsDone() && afterGetUserByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersRepositoryMock.GetUserByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserByIDMock.expectedInvocations), m.GetUserByIDMock.expectedInvocationsOrigin, afterGetUserByIDCounter)
	}
}

type mUsersRepositoryMockSaveUser struct {
	optional           bool
	mock               *UsersRepositoryMock
	defaultExpectation *UsersRepositoryMockSaveUserExpectation
	expectations       []*UsersRepositoryMockSaveUserExpectation

	callArgs []*UsersRepositoryMockSaveUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UsersRepositoryMockSaveUserExpectation specifies expectation struct of the UsersRepository.SaveUser
type UsersRepositoryMockSaveUserExpectation struct {
	mock               *UsersRepositoryMock
	params             *UsersRepositoryMockSaveUserParams
	paramPtrs          *UsersRepositoryMockSaveUserParamPtrs
	expectationOrigins UsersRepositoryMockSaveUserExpectationOrigins
	results            *UsersRepositoryMockSaveUserResults
	returnOrigin       string
	Counter            uint64
}

// UsersRepositoryMockSaveUserParams contains parameters of the UsersRepository.SaveUser
type UsersRepositoryMockSaveUserParams struct {
	ctx      context.Context
	email    string
	password string
}

// UsersRepositoryMockSaveUserParamPtrs contains pointers to parameters of the UsersRepository.SaveUser
type UsersRepositoryMockSaveUserParamPtrs struct {
	ctx      *context.Context
	email    *string
	password *string
}

// UsersRepositoryMockSaveUserResults contains results of the UsersRepository.SaveUser
type UsersRepositoryMockSaveUserResults struct {
	up1 *models.User
	err error
}

// UsersRepositoryMockSaveUserOrigins contains origins of expectations of the UsersRepository.SaveUser
type UsersRepositoryMockSaveUserExpectationOrigins struct {
	origin         string
	originCtx      string
	originEmail    string
	originPassword string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSaveUser *mUsersRepositoryMockSaveUser) Optional() *mUsersRepositoryMockSaveUser {
	mmSaveUser.optional = true
	return mmSaveUser
}

// Expect sets up expected params for UsersRepository.SaveUser
func (mmSaveUser *mUsersRepositoryMockSaveUser) Expect(ctx context.Context, email string, password string) *mUsersRepositoryMockSaveUser {
	if mmSaveUser.mock.funcSaveUser != nil {
		mmSaveUser.mock.t.Fatalf("UsersRepositoryMock.SaveUser mock is already set by Set")
	}

	if mmSaveUser.defaultExpectation == nil {
		mmSaveUser.defaultExpectation = &UsersRepositoryMockSaveUserExpectation{}
	}

	if mmSaveUser.defaultExpectation.paramPtrs != nil {
		mmSaveUser.mock.t.Fatalf("UsersRepositoryMock.SaveUser mock is already set by ExpectParams functions")
	}

	mmSaveUser.defaultExpectation.params = &UsersRepositoryMockSaveUserParams{ctx, email, password}
	mmSaveUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSaveUser.expectations {
		if minimock.Equal(e.params, mmSaveUser.defaultExpectation.params) {
			mmSaveUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveUser.defaultExpectation.params)
		}
	}

	return mmSaveUser
}

// ExpectCtxParam1 sets up expected param ctx for UsersRepository.SaveUser
func (mmSaveUser *mUsersRepositoryMockSaveUser) ExpectCtxParam1(ctx context.Context) *mUsersRepositoryMockSaveUser {
	if mmSaveUser.mock.funcSaveUser != nil {
		mmSaveUser.mock.t.Fatalf("UsersRepositoryMock.SaveUser mock is already set by Set")
	}

	if mmSaveUser.defaultExpectation == nil {
		mmSaveUser.defaultExpectation = &UsersRepositoryMockSaveUserExpectation{}
	}

	if mmSaveUser.defaultExpectation.params != nil {
		mmSaveUser.mock.t.Fatalf("UsersRepositoryMock.SaveUser mock is already set by Expect")
	}

	if mmSaveUser.defaultExpectation.paramPtrs == nil {
		mmSaveUser.defaultExpectation.paramPtrs = &UsersRepositoryMockSaveUserParamPtrs{}
	}
	mmSaveUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmSaveUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSaveUser
}

// ExpectEmailParam2 sets up expected param email for UsersRepository.SaveUser
func (mmSaveUser *mUsersRepositoryMockSaveUser) ExpectEmailParam2(email string) *mUsersRepositoryMockSaveUser {
	if mmSaveUser.mock.funcSaveUser != nil {
		mmSaveUser.mock.t.Fatalf("UsersRepositoryMock.SaveUser mock is already set by Set")
	}

	if mmSaveUser.defaultExpectation == nil {
		mmSaveUser.defaultExpectation = &UsersRepositoryMockSaveUserExpectation{}
	}

	if mmSaveUser.defaultExpectation.params != nil {
		mmSaveUser.mock.t.Fatalf("UsersRepositoryMock.SaveUser mock is already set by Expect")
	}

	if mmSaveUser.defaultExpectation.paramPtrs == nil {
		mmSaveUser.defaultExpectation.paramPtrs = &UsersRepositoryMockSaveUserParamPtrs{}
	}
	mmSaveUser.defaultExpectation.paramPtrs.email = &email
	mmSaveUser.defaultExpectation.expectationOrigins.originEmail = minimock.CallerInfo(1)

	return mmSaveUser
}

// ExpectPasswordParam3 sets up expected param password for UsersRepository.SaveUser
func (mmSaveUser *mUsersRepositoryMockSaveUser) ExpectPasswordParam3(password string) *mUsersRepositoryMockSaveUser {
	if mmSaveUser.mock.funcSaveUser != nil {
		mmSaveUser.mock.t.Fatalf("UsersRepositoryMock.SaveUser mock is already set by Set")
	}

	if mmSaveUser.defaultExpectation == nil {
		mmSaveUser.defaultExpectation = &UsersRepositoryMockSaveUserExpectation{}
	}

	if mmSaveUser.defaultExpectation.params != nil {
		mmSaveUser.mock.t.Fatalf("UsersRepositoryMock.SaveUser mock is already set by Expect")
	}

	if mmSaveUser.defaultExpectation.paramPtrs == nil {
		mmSaveUser.defaultExpectation.paramPtrs = &UsersRepositoryMockSaveUserParamPtrs{}
	}
	mmSaveUser.defaultExpectation.paramPtrs.password = &password
	mmSaveUser.defaultExpectation.expectationOrigins.originPassword = minimock.CallerInfo(1)

	return mmSaveUser
}

// Inspect accepts an inspector function that has same arguments as the UsersRepository.SaveUser
func (mmSaveUser *mUsersRepositoryMockSaveUser) Inspect(f func(ctx context.Context, email string, password string)) *mUsersRepositoryMockSaveUser {
	if mmSaveUser.mock.inspectFuncSaveUser != nil {
		mmSaveUser.mock.t.Fatalf("Inspect function is already set for UsersRepositoryMock.SaveUser")
	}

	mmSaveUser.mock.inspectFuncSaveUser = f

	return mmSaveUser
}

// Return sets up results that will be returned by UsersRepository.SaveUser
func (mmSaveUser *mUsersRepositoryMockSaveUser) Return(up1 *models.User, err error) *UsersRepositoryMock {
	if mmSaveUser.mock.funcSaveUser != nil {
		mmSaveUser.mock.t.Fatalf("UsersRepositoryMock.SaveUser mock is already set by Set")
	}

	if mmSaveUser.defaultExpectation == nil {
		mmSaveUser.defaultExpectation = &UsersRepositoryMockSaveUserExpectation{mock: mmSaveUser.mock}
	}
	mmSaveUser.defaultExpectation.results = &UsersRepositoryMockSaveUserResults{up1, err}
	mmSaveUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSaveUser.mock
}

// Set uses given function f to mock the UsersRepository.SaveUser method
func (mmSaveUser *mUsersRepositoryMockSaveUser) Set(f func(ctx context.Context, email string, password string) (up1 *models.User, err error)) *UsersRepositoryMock {
	if mmSaveUser.defaultExpectation != nil {
		mmSaveUser.mock.t.Fatalf("Default expectation is already set for the UsersRepository.SaveUser method")
	}

	if len(mmSaveUser.expectations) > 0 {
		mmSaveUser.mock.t.Fatalf("Some expectations are already set for the UsersRepository.SaveUser method")
	}

	mmSaveUser.mock.funcSaveUser = f
	mmSaveUser.mock.funcSaveUserOrigin = minimock.CallerInfo(1)
	return mmSaveUser.mock
}

// When sets expectation for the UsersRepository.SaveUser which will trigger the result defined by the following
// Then helper
func (mmSaveUser *mUsersRepositoryMockSaveUser) When(ctx context.Context, email string, password string) *UsersRepositoryMockSaveUserExpectation {
	if mmSaveUser.mock.funcSaveUser != nil {
		mmSaveUser.mock.t.Fatalf("UsersRepositoryMock.SaveUser mock is already set by Set")
	}

	expectation := &UsersRepositoryMockSaveUserExpectation{
		mock:               mmSaveUser.mock,
		params:             &UsersRepositoryMockSaveUserParams{ctx, email, password},
		expectationOrigins: UsersRepositoryMockSaveUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSaveUser.expectations = append(mmSaveUser.expectations, expectation)
	return expectation
}

// Then sets up UsersRepository.SaveUser return parameters for the expectation previously defined by the When method
func (e *UsersRepositoryMockSaveUserExpectation) Then(up1 *models.User, err error) *UsersRepositoryMock {
	e.results = &UsersRepositoryMockSaveUserResults{up1, err}
	return e.mock
}

// Times sets number of times UsersRepository.SaveUser should be invoked
func (mmSaveUser *mUsersRepositoryMockSaveUser) Times(n uint64) *mUsersRepositoryMockSaveUser {
	if n == 0 {
		mmSaveUser.mock.t.Fatalf("Times of UsersRepositoryMock.SaveUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSaveUser.expectedInvocations, n)
	mmSaveUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSaveUser
}

func (mmSaveUser *mUsersRepositoryMockSaveUser) invocationsDone() bool {
	if len(mmSaveUser.expectations) == 0 && mmSaveUser.defaultExpectation == nil && mmSaveUser.mock.funcSaveUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSaveUser.mock.afterSaveUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSaveUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SaveUser implements mm_usecase.UsersRepository
func (mmSaveUser *UsersRepositoryMock) SaveUser(ctx context.Context, email string, password string) (up1 *models.User, err error) {
	mm_atomic.AddUint64(&mmSaveUser.beforeSaveUserCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveUser.afterSaveUserCounter, 1)

	mmSaveUser.t.Helper()

	if mmSaveUser.inspectFuncSaveUser != nil {
		mmSaveUser.inspectFuncSaveUser(ctx, email, password)
	}

	mm_params := UsersRepositoryMockSaveUserParams{ctx, email, password}

	// Record call args
	mmSaveUser.SaveUserMock.mutex.Lock()
	mmSaveUser.SaveUserMock.callArgs = append(mmSaveUser.SaveUserMock.callArgs, &mm_params)
	mmSaveUser.SaveUserMock.mutex.Unlock()

	for _, e := range mmSaveUser.SaveUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmSaveUser.SaveUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveUser.SaveUserMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveUser.SaveUserMock.defaultExpectation.params
		mm_want_ptrs := mmSaveUser.SaveUserMock.defaultExpectation.paramPtrs

		mm_got := UsersRepositoryMockSaveUserParams{ctx, email, password}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSaveUser.t.Errorf("UsersRepositoryMock.SaveUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveUser.SaveUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.email != nil && !minimock.Equal(*mm_want_ptrs.email, mm_got.email) {
				mmSaveUser.t.Errorf("UsersRepositoryMock.SaveUser got unexpected parameter email, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveUser.SaveUserMock.defaultExpectation.expectationOrigins.originEmail, *mm_want_ptrs.email, mm_got.email, minimock.Diff(*mm_want_ptrs.email, mm_got.email))
			}

			if mm_want_ptrs.password != nil && !minimock.Equal(*mm_want_ptrs.password, mm_got.password) {
				mmSaveUser.t.Errorf("UsersRepositoryMock.SaveUser got unexpected parameter password, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveUser.SaveUserMock.defaultExpectation.expectationOrigins.originPassword, *mm_want_ptrs.password, mm_got.password, minimock.Diff(*mm_want_ptrs.password, mm_got.password))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveUser.t.Errorf("UsersRepositoryMock.SaveUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSaveUser.SaveUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveUser.SaveUserMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveUser.t.Fatal("No results are set for the UsersRepositoryMock.SaveUser")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmSaveUser.funcSaveUser != nil {
		return mmSaveUser.funcSaveUser(ctx, email, password)
	}
	mmSaveUser.t.Fatalf("Unexpected call to UsersRepositoryMock.SaveUser. %v %v %v", ctx, email, password)
	return
}

// SaveUserAfterCounter returns a count of finished UsersRepositoryMock.SaveUser invocations
func (mmSaveUser *UsersRepositoryMock) SaveUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveUser.afterSaveUserCounter)
}

// SaveUserBeforeCounter returns a count of UsersRepositoryMock.SaveUser invocations
func (mmSaveUser *UsersRepositoryMock) SaveUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveUser.beforeSaveUserCounter)
}

// Calls returns a list of arguments used in each call to UsersRepositoryMock.SaveUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveUser *mUsersRepositoryMockSaveUser) Calls() []*UsersRepositoryMockSaveUserParams {
	mmSaveUser.mutex.RLock()

	argCopy := make([]*UsersRepositoryMockSaveUserParams, len(mmSaveUser.callArgs))
	copy(argCopy, mmSaveUser.callArgs)

	mmSaveUser.mutex.RUnlock()

	return argCopy
}

// MinimockSaveUserDone returns true if the count of the SaveUser invocations corresponds
// the number of defined expectations
func (m *UsersRepositoryMock) MinimockSaveUserDone() bool {
	if m.SaveUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SaveUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SaveUserMock.invocationsDone()
}

// MinimockSaveUserInspect logs each unmet expectation
func (m *UsersRepositoryMock) MinimockSaveUserInspect() {
	for _, e := range m.SaveUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersRepositoryMock.SaveUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSaveUserCounter := mm_atomic.LoadUint64(&m.afterSaveUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SaveUserMock.defaultExpectation != nil && afterSaveUserCounter < 1 {
		if m.SaveUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UsersRepositoryMock.SaveUser at\n%s", m.SaveUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UsersRepositoryMock.SaveUser at\n%s with params: %#v", m.SaveUserMock.defaultExpectation.expectationOrigins.origin, *m.SaveUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveUser != nil && afterSaveUserCounter < 1 {
		m.t.Errorf("Expected call to UsersRepositoryMock.SaveUser at\n%s", m.funcSaveUserOrigin)
	}

	if !m.SaveUserMock.invocationsDone() && afterSaveUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersRepositoryMock.SaveUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SaveUserMock.expectedInvocations), m.SaveUserMock.expectedInvocationsOrigin, afterSaveUserCounter)
	}
}

type mUsersRepositoryMockUpdateUser struct {
	optional           bool
	mock               *UsersRepositoryMock
	defaultExpectation *UsersRepositoryMockUpdateUserExpectation
	expectations       []*UsersRepositoryMockUpdateUserExpectation

	callArgs []*UsersRepositoryMockUpdateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UsersRepositoryMockUpdateUserExpectation specifies expectation struct of the UsersRepository.UpdateUser
type UsersRepositoryMockUpdateUserExpectation struct {
	mock               *UsersRepositoryMock
	params             *UsersRepositoryMockUpdateUserParams
	paramPtrs          *UsersRepositoryMockUpdateUserParamPtrs
	expectationOrigins UsersRepositoryMockUpdateUserExpectationOrigins
	results            *UsersRepositoryMockUpdateUserResults
	returnOrigin       string
	Counter            uint64
}

// UsersRepositoryMockUpdateUserParams contains parameters of the UsersRepository.UpdateUser
type UsersRepositoryMockUpdateUserParams struct {
	ctx  context.Context
	user *models.User
}

// UsersRepositoryMockUpdateUserParamPtrs contains pointers to parameters of the UsersRepository.UpdateUser
type UsersRepositoryMockUpdateUserParamPtrs struct {
	ctx  *context.Context
	user **models.User
}

// UsersRepositoryMockUpdateUserResults contains results of the UsersRepository.UpdateUser
type UsersRepositoryMockUpdateUserResults struct {
	err error
}

// UsersRepositoryMockUpdateUserOrigins contains origins of expectations of the UsersRepository.UpdateUser
type UsersRepositoryMockUpdateUserExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateUser *mUsersRepositoryMockUpdateUser) Optional() *mUsersRepositoryMockUpdateUser {
	mmUpdateUser.optional = true
	return mmUpdateUser
}

// Expect sets up expected params for UsersRepository.UpdateUser
func (mmUpdateUser *mUsersRepositoryMockUpdateUser) Expect(ctx context.Context, user *models.User) *mUsersRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UsersRepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UsersRepositoryMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.paramPtrs != nil {
		mmUpdateUser.mock.t.Fatalf("UsersRepositoryMock.UpdateUser mock is already set by ExpectParams functions")
	}

	mmUpdateUser.defaultExpectation.params = &UsersRepositoryMockUpdateUserParams{ctx, user}
	mmUpdateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateUser.expectations {
		if minimock.Equal(e.params, mmUpdateUser.defaultExpectation.params) {
			mmUpdateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUser.defaultExpectation.params)
		}
	}

	return mmUpdateUser
}

// ExpectCtxParam1 sets up expected param ctx for UsersRepository.UpdateUser
func (mmUpdateUser *mUsersRepositoryMockUpdateUser) ExpectCtxParam1(ctx context.Context) *mUsersRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UsersRepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UsersRepositoryMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("UsersRepositoryMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &UsersRepositoryMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateUser
}

// ExpectUserParam2 sets up expected param user for UsersRepository.UpdateUser
func (mmUpdateUser *mUsersRepositoryMockUpdateUser) ExpectUserParam2(user *models.User) *mUsersRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UsersRepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UsersRepositoryMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("UsersRepositoryMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &UsersRepositoryMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.user = &user
	mmUpdateUser.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmUpdateUser
}

// Inspect accepts an inspector function that has same arguments as the UsersRepository.UpdateUser
func (mmUpdateUser *mUsersRepositoryMockUpdateUser) Inspect(f func(ctx context.Context, user *models.User)) *mUsersRepositoryMockUpdateUser {
	if mmUpdateUser.mock.inspectFuncUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("Inspect function is already set for UsersRepositoryMock.UpdateUser")
	}

	mmUpdateUser.mock.inspectFuncUpdateUser = f

	return mmUpdateUser
}

// Return sets up results that will be returned by UsersRepository.UpdateUser
func (mmUpdateUser *mUsersRepositoryMockUpdateUser) Return(err error) *UsersRepositoryMock {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UsersRepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UsersRepositoryMockUpdateUserExpectation{mock: mmUpdateUser.mock}
	}
	mmUpdateUser.defaultExpectation.results = &UsersRepositoryMockUpdateUserResults{err}
	mmUpdateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// Set uses given function f to mock the UsersRepository.UpdateUser method
func (mmUpdateUser *mUsersRepositoryMockUpdateUser) Set(f func(ctx context.Context, user *models.User) (err error)) *UsersRepositoryMock {
	if mmUpdateUser.defaultExpectation != nil {
		mmUpdateUser.mock.t.Fatalf("Default expectation is already set for the UsersRepository.UpdateUser method")
	}

	if len(mmUpdateUser.expectations) > 0 {
		mmUpdateUser.mock.t.Fatalf("Some expectations are already set for the UsersRepository.UpdateUser method")
	}

	mmUpdateUser.mock.funcUpdateUser = f
	mmUpdateUser.mock.funcUpdateUserOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// When sets expectation for the UsersRepository.UpdateUser which will trigger the result defined by the following
// Then helper
func (mmUpdateUser *mUsersRepositoryMockUpdateUser) When(ctx context.Context, user *models.User) *UsersRepositoryMockUpdateUserExpectation {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UsersRepositoryMock.UpdateUser mock is already set by Set")
	}

	expectation := &UsersRepositoryMockUpdateUserExpectation{
		mock:               mmUpdateUser.mock,
		params:             &UsersRepositoryMockUpdateUserParams{ctx, user},
		expectationOrigins: UsersRepositoryMockUpdateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateUser.expectations = append(mmUpdateUser.expectations, expectation)
	return expectation
}

// Then sets up UsersRepository.UpdateUser return parameters for the expectation previously defined by the When method
func (e *UsersRepositoryMockUpdateUserExpectation) Then(err error) *UsersRepositoryMock {
	e.results = &UsersRepositoryMockUpdateUserResults{err}
	return e.mock
}

// Times sets number of times UsersRepository.UpdateUser should be invoked
func (mmUpdateUser *mUsersRepositoryMockUpdateUser) Times(n uint64) *mUsersRepositoryMockUpdateUser {
	if n == 0 {
		mmUpdateUser.mock.t.Fatalf("Times of UsersRepositoryMock.UpdateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateUser.expectedInvocations, n)
	mmUpdateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateUser
}

func (mmUpdateUser *mUsersRepositoryMockUpdateUser) invocationsDone() bool {
	if len(mmUpdateUser.expectations) == 0 && mmUpdateUser.defaultExpectation == nil && mmUpdateUser.mock.funcUpdateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateUser.mock.afterUpdateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateUser implements mm_usecase.UsersRepository
func (mmUpdateUser *UsersRepositoryMock) UpdateUser(ctx context.Context, user *models.User) (err error) {
	mm_atomic.AddUint64(&mmUpdateUser.beforeUpdateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUser.afterUpdateUserCounter, 1)

	mmUpdateUser.t.Helper()

	if mmUpdateUser.inspectFuncUpdateUser != nil {
		mmUpdateUser.inspectFuncUpdateUser(ctx, user)
	}

	mm_params := UsersRepositoryMockUpdateUserParams{ctx, user}

	// Record call args
	mmUpdateUser.UpdateUserMock.mutex.Lock()
	mmUpdateUser.UpdateUserMock.callArgs = append(mmUpdateUser.UpdateUserMock.callArgs, &mm_params)
	mmUpdateUser.UpdateUserMock.mutex.Unlock()

	for _, e := range mmUpdateUser.UpdateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateUser.UpdateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUser.UpdateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUser.UpdateUserMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateUser.UpdateUserMock.defaultExpectation.paramPtrs

		mm_got := UsersRepositoryMockUpdateUserParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateUser.t.Errorf("UsersRepositoryMock.UpdateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmUpdateUser.t.Errorf("UsersRepositoryMock.UpdateUser got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUser.t.Errorf("UsersRepositoryMock.UpdateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUser.UpdateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUser.t.Fatal("No results are set for the UsersRepositoryMock.UpdateUser")
		}
		return (*mm_results).err
	}
	if mmUpdateUser.funcUpdateUser != nil {
		return mmUpdateUser.funcUpdateUser(ctx, user)
	}
	mmUpdateUser.t.Fatalf("Unexpected call to UsersRepositoryMock.UpdateUser. %v %v", ctx, user)
	return
}

// UpdateUserAfterCounter returns a count of finished UsersRepositoryMock.UpdateUser invocations
func (mmUpdateUser *UsersRepositoryMock) UpdateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.afterUpdateUserCounter)
}

// UpdateUserBeforeCounter returns a count of UsersRepositoryMock.UpdateUser invocations
func (mmUpdateUser *UsersRepositoryMock) UpdateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.beforeUpdateUserCounter)
}

// Calls returns a list of arguments used in each call to UsersRepositoryMock.UpdateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUser *mUsersRepositoryMockUpdateUser) Calls() []*UsersRepositoryMockUpdateUserParams {
	mmUpdateUser.mutex.RLock()

	argCopy := make([]*UsersRepositoryMockUpdateUserParams, len(mmUpdateUser.callArgs))
	copy(argCopy, mmUpdateUser.callArgs)

	mmUpdateUser.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserDone returns true if the count of the UpdateUser invocations corresponds
// the number of defined expectations
func (m *UsersRepositoryMock) MinimockUpdateUserDone() bool {
	if m.UpdateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateUserMock.invocationsDone()
}

// MinimockUpdateUserInspect logs each unmet expectation
func (m *UsersRepositoryMock) MinimockUpdateUserInspect() {
	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersRepositoryMock.UpdateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateUserCounter := mm_atomic.LoadUint64(&m.afterUpdateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserMock.defaultExpectation != nil && afterUpdateUserCounter < 1 {
		if m.UpdateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UsersRepositoryMock.UpdateUser at\n%s", m.UpdateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UsersRepositoryMock.UpdateUser at\n%s with params: %#v", m.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *m.UpdateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUser != nil && afterUpdateUserCounter < 1 {
		m.t.Errorf("Expected call to UsersRepositoryMock.UpdateUser at\n%s", m.funcUpdateUserOrigin)
	}

	if !m.UpdateUserMock.invocationsDone() && afterUpdateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersRepositoryMock.UpdateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateUserMock.expectedInvocations), m.UpdateUserMock.expectedInvocationsOrigin, afterUpdateUserCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UsersRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetUserByEmailInspect()

			m.MinimockGetUserByIDInspect()

			m.MinimockSaveUserInspect()

			m.MinimockUpdateUserInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UsersRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UsersRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetUserByEmailDone() &&
		m.MinimockGetUserByIDDone() &&
		m.MinimockSaveUserDone() &&
		m.MinimockUpdateUserDone()
}
